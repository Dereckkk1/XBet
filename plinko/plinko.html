<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plinko Game</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    canvas {
      background: #222;
      display: block;
      margin: 0 auto;
    }
    #scoreboard {
      margin: 20px;
      font-size: 1.2rem;
    }
    button {
      padding: 10px 20px;
      font-size: 1rem;
      background-color: #00b894;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
    }
    button:hover {
      background-color: #019875;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¯ Plinko Game ðŸŽ¯</h1>
  <div id="scoreboard">Total Score: <span id="score">0</span></div>
  <canvas id="plinkoCanvas" width="1000" height="800"></canvas>
  <button onclick="dropBall()">Drop Ball</button>

  <script>
    const canvas = document.getElementById('plinkoCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    const pegs = [];
    const balls = [];
    const particles = [];

    const slots = [20, 10, 5, 3, 2, 1.3, 1.2, 1.1, 0.6, 1.1, 1.2, 1.3, 2, 3, 5, 10, 20];
    const slotWidth = width / slots.length;
    let score = 0;

    class Peg {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 4;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#ccc';
        ctx.fill();
        ctx.closePath();
      }
    }

    class Ball {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 6;
        this.dy = 0;
        this.dx = 0;
        this.stopped = false;
      }
      update() {
        if (this.stopped) return;

        this.dy += 0.25;
        this.y += this.dy;
        this.x += this.dx;

        if (this.x < this.radius || this.x > width - this.radius) {
          this.dx *= -0.6;
          this.x = Math.max(this.radius, Math.min(this.x, width - this.radius));
        }

        for (let peg of pegs) {
          const dx = this.x - peg.x;
          const dy = this.y - peg.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = this.radius + peg.radius;

          if (dist < minDist) {
            const angle = Math.atan2(dy, dx);
            const repel = 2;
            this.dx += Math.cos(angle) * repel;
            this.dy += Math.sin(angle) * repel;

            // ManipulaÃ§Ã£o de fÃ­sica enviesada
            const center = width / 2;
            const bias = (this.x - center) / center; // de -1 a 1

            if (Math.abs(bias) < 0.05) {
              this.dx += (Math.random() - 0.5) * 1;
            } else {
              this.dx -= bias * Math.abs(bias) * 3; // puxando para o centro
            }

            this.dx *= 0.7;
            this.dy *= 0.7;
          }
        }

        if (this.y > height - 30 && !this.stopped) {
          const index = Math.floor(this.x / slotWidth);
          score += slots[index] || 0;
          document.getElementById('score').textContent = score.toFixed(2);
          this.stopped = true;
          showScoreText(this.x, this.y, slots[index] || 0);
          generateParticles(this.x, this.y);
        }
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#f39c12';
        ctx.fill();
        ctx.closePath();
      }
    }

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 3 + 2;
        this.dx = (Math.random() - 0.5) * 6;
        this.dy = (Math.random() - 0.5) * 6;
        this.alpha = 1;
        this.color = `hsl(${Math.random() * 360}, 100%, 60%)`;
      }
      update() {
        this.x += this.dx;
        this.y += this.dy;
        this.alpha -= 0.02;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color.replace('hsl', 'hsla').replace(')', `, ${this.alpha})`);
        ctx.fill();
      }
    }

    function generateParticles(x, y) {
      for (let i = 0; i < 20; i++) {
        particles.push(new Particle(x, y));
      }
    }

    function createPyramidPegs() {
      const spacingX = 35;
      const spacingY = 35;
      const rows = 16;
      const centerX = width / 2;
      const startY = 100;

      for (let row = 0; row < rows; row++) {
        const y = startY + row * spacingY;
        const pegsInRow = row + 1;
        const rowWidth = spacingX * (pegsInRow - 1);
        const offsetX = centerX - rowWidth / 2;
        for (let i = 0; i < pegsInRow; i++) {
          const x = offsetX + i * spacingX;
          pegs.push(new Peg(x, y));
        }
      }
    }

    function drawSlots() {
      for (let i = 0; i < slots.length; i++) {
        const x = i * slotWidth;
        ctx.fillStyle = '#c0392b';
        ctx.fillRect(x, height - 30, slotWidth, 30);
        ctx.fillStyle = '#fff';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(slots[i], x + slotWidth / 2, height - 10);
      }
    }

    function dropBall() {
      balls.push(new Ball(width / 2, 30));
    }

    const floatingScores = [];
    function showScoreText(x, y, value) {
      floatingScores.push({ x, y, value, alpha: 1 });
    }

    function drawFloatingScores() {
      for (let i = 0; i < floatingScores.length; i++) {
        const fs = floatingScores[i];
        ctx.font = '18px Arial';
        ctx.fillStyle = `rgba(255, 255, 0, ${fs.alpha})`;
        ctx.fillText(`+${valueFormat(fs.value)}`, fs.x, fs.y);
        fs.y -= 1;
        fs.alpha -= 0.02;
        if (fs.alpha <= 0) floatingScores.splice(i--, 1);
      }
    }

    function updateAndDrawParticles() {
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.update();
        p.draw();
        if (p.alpha <= 0) particles.splice(i--, 1);
      }
    }

    function valueFormat(v) {
      return (typeof v === 'number') ? (v % 1 ? v.toFixed(1) : v) : v;
    }

    function animate() {
      ctx.clearRect(0, 0, width, height);
      for (let peg of pegs) peg.draw();
      drawSlots();
      for (let ball of balls) {
        ball.update();
        ball.draw();
      }
      drawFloatingScores();
      updateAndDrawParticles();
      requestAnimationFrame(animate);
    }

    createPyramidPegs();
    animate();
  </script>
</body>
</html>
